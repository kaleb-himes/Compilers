MP_PROGRAM     1   1   program
MP_IDENTIFIER  1   9   Tester
MP_SCOLON      1   15   ;
MP_VAR         3   2   var
MP_IDENTIFIER  3   6   I
MP_COLON       3   7   :
MP_INTEGER     3   9   Integer
MP_SCOLON      3   16   ;
MP_PROCEDURE   5   5   procedure
MP_IDENTIFIER  5   15   junk
MP_LPAREN      5   20   (
MP_VAR         5   21   VAR
MP_IDENTIFIER  5   25   test
MP_COLON       5   29   :
MP_FLOAT       5   30   Float
MP_SCOLON      5   35   ;
MP_VAR         5   37   VAR
MP_IDENTIFIER  5   41   garbage
MP_COMMA       5   48   ,
MP_IDENTIFIER  5   49   junk
MP_COMMA       5   53   ,
MP_IDENTIFIER  5   54   plop
MP_COLON       5   58   :
MP_BOOLEAN     5   59   Boolean
MP_RPAREN      5   66   )
MP_SCOLON      5   67   ;
MP_BEGIN       6   5   begin
MP_READ        7   9   read
MP_LPAREN      7   13   (
MP_IDENTIFIER  7   14   somestuff
MP_RPAREN      7   23   )
MP_END         8   5   end
MP_SCOLON      8   8   ;
MP_COMMENT     8   10   {tester}
MP_FUNCTION    10   5   function
MP_IDENTIFIER  10   14   junk
MP_LPAREN      10   19   (
MP_VAR         10   20   VAR
MP_IDENTIFIER  10   24   test
MP_COLON       10   28   :
MP_FLOAT       10   29   Float
MP_SCOLON      10   34   ;
MP_VAR         10   36   VAR
MP_IDENTIFIER  10   40   garbage
MP_COLON       10   47   :
MP_BOOLEAN     10   48   Boolean
MP_RPAREN      10   55   )
MP_COLON       10   57   :
MP_BOOLEAN     10   59   Boolean
MP_SCOLON      10   66   ;
MP_BEGIN       11   5   begin
MP_READ        12   9   read
MP_LPAREN      12   13   (
MP_IDENTIFIER  12   14   somestuff
MP_RPAREN      12   23   )
MP_END         13   5   end
MP_SCOLON      13   8   ;
MP_COMMENT     13   10   {tester}
MP_FUNCTION    15   5   function
MP_IDENTIFIER  15   14   junk
MP_LPAREN      15   19   (
MP_VAR         15   20   VAR
MP_IDENTIFIER  15   24   test
MP_COLON       15   28   :
MP_FLOAT       15   29   Float
MP_RPAREN      15   34   )
MP_COLON       15   36   :
MP_STRING      15   38   STRING
MP_SCOLON      15   44   ;
MP_BEGIN       16   5   begin
MP_READ        17   9   read
MP_LPAREN      17   13   (
MP_IDENTIFIER  17   14   somestuff
MP_RPAREN      17   23   )
MP_END         18   5   end
MP_SCOLON      18   8   ;
MP_COMMENT     18   10   {tester}
MP_FUNCTION    20   5   function
MP_IDENTIFIER  20   14   junk
MP_LPAREN      20   19   (
MP_VAR         20   20   VAR
MP_IDENTIFIER  20   24   test
MP_COLON       20   28   :
MP_FLOAT       20   29   Float
MP_RPAREN      20   34   )
MP_COLON       20   36   :
MP_FLOAT       20   38   FLOAT
MP_SCOLON      20   43   ;
MP_BEGIN       21   5   begin
MP_READ        22   9   read
MP_LPAREN      22   13   (
MP_IDENTIFIER  22   14   somestuff
MP_RPAREN      22   23   )
MP_END         23   5   end
MP_SCOLON      23   8   ;
MP_COMMENT     23   10   {tester}
MP_COMMENT     25   1   {procedure this (VAR example:integer x, Var garbage:FLOAT y)}
MP_BEGIN       26   3   begin
MP_COMMENT     26   9   {tester}
MP_WRITELN     27   5   Writeln
MP_LPAREN      27   12   (
MP_STRING_LIT  27   13   hi
MP_RPAREN      27   15   )
MP_SCOLON      27   16   ;
MP_WRITELN     27   18   Writeln
MP_LPAREN      27   25   (
MP_STRING_LIT  27   26   THis is a crazy string for testing purposes.
MP_RPAREN      27   70   )
MP_SCOLON      27   71   ;
MP_WRITE       28   5   Write
MP_LPAREN      28   10   (
MP_STRING_LIT  28   11   Please enter an integer value for I: 
MP_RPAREN      28   48   )
MP_SCOLON      28   49   ;
MP_READ        29   5   Read
MP_LPAREN      29   9   (
MP_IDENTIFIER  29   10   I
MP_RPAREN      29   11   )
MP_SCOLON      29   12   ;
MP_IDENTIFIER  30   5   I
MP_ASSIGN      30   7   :=
MP_IDENTIFIER  30   11   I
MP_PLUS        30   13   +
MP_INTEGER_LIT 30   15   1
MP_SCOLON      30   16   ;
MP_FOR         32   5   FOR
MP_IDENTIFIER  32   9   I
MP_ASSIGN      32   10   :=
MP_INTEGER_LIT 32   13   5
MP_TO          32   15   to
MP_INTEGER_LIT 32   18   12
MP_DO          32   21   do
MP_IF          33   9   If
MP_IDENTIFIER  33   12   I
MP_GEQUAL      33   14   >=
MP_INTEGER_LIT 33   18   6
MP_THEN        33   20   then
MP_WRITE       34   13   Write
MP_LPAREN      34   19   (
MP_STRING_LIT  34   21   this stuff
MP_RPAREN      34   31   )
MP_ELSE        35   9   else
MP_WRITE       36   13   Write
MP_LPAREN      36   19   (
MP_STRING_LIT  36   21   that stuff
MP_RPAREN      36   31   )
MP_SCOLON      36   32   ;
MP_IDENTIFIER  37   9   I
MP_ASSIGN      37   11   :=
MP_IDENTIFIER  37   15   I
MP_PLUS        37   17   +
MP_INTEGER_LIT 37   19   1
MP_SCOLON      37   20   ;
MP_FOR         39   5   FOR
MP_IDENTIFIER  39   9   I
MP_ASSIGN      39   10   :=
MP_INTEGER_LIT 39   13   5
MP_DOWNTO      39   15   downto
MP_INTEGER_LIT 39   22   12
MP_DO          39   25   do
MP_IF          40   9   If
MP_IDENTIFIER  40   12   I
MP_LEQUAL      40   14   <=
MP_MINUS       40   18   -
MP_INTEGER_LIT 40   19   6
MP_THEN        40   21   then
MP_WRITE       41   13   Write
MP_LPAREN      41   19   (
MP_STRING_LIT  41   21   this stuff
MP_RPAREN      41   31   )
MP_COMMENT     41   33   {just in case}
MP_ELSE        42   9   else
MP_WRITE       43   13   Write
MP_LPAREN      43   19   (
MP_STRING_LIT  43   21   that stuff
MP_RPAREN      43   31   )
MP_SCOLON      43   32   ;
MP_IDENTIFIER  44   9   I
MP_ASSIGN      44   11   :=
MP_IDENTIFIER  44   15   I
MP_PLUS        44   17   +
MP_INTEGER_LIT 44   19   1
MP_SCOLON      44   20   ;
MP_IF          45   9   If
MP_IDENTIFIER  45   12   I
MP_LEQUAL      45   14   <=
MP_MINUS       45   18   -
MP_INTEGER_LIT 45   19   6
MP_THEN        45   21   then
MP_WRITE       46   13   Write
MP_LPAREN      46   19   (
MP_STRING_LIT  46   21   this stuff
MP_RPAREN      46   31   )
MP_SCOLON      46   32   ;
MP_WHILE       48   5   While
MP_LPAREN      48   11   (
MP_IDENTIFIER  48   12   I
MP_NEQUAL      48   14   <>
MP_INTEGER_LIT 48   18   20
MP_RPAREN      48   20   )
MP_DO          48   22   do
MP_IDENTIFIER  49   9   I
MP_ASSIGN      49   11   :=
MP_IDENTIFIER  49   15   I
MP_PLUS        49   17   +
MP_INTEGER_LIT 49   19   1
MP_SCOLON      49   20   ;
MP_REPEAT      51   5   Repeat
MP_IDENTIFIER  52   9   I
MP_ASSIGN      52   11   :=
MP_INTEGER_LIT 52   15   5
MP_UNTIL       53   9   until
MP_LPAREN      53   15   (
MP_IDENTIFIER  53   16   I
MP_NEQUAL      53   18   <>
MP_INTEGER_LIT 53   22   5
MP_RPAREN      53   23   )
MP_SCOLON      53   24   ;
MP_WRITELN     55   5   Writeln
MP_LPAREN      55   12   (
MP_STRING_LIT  55   13   The current value of I is 
MP_COMMA       55   39   ,
MP_IDENTIFIER  55   41   I
MP_EQUAL       55   43   =
MP_INTEGER_LIT 55   45   0
MP_RPAREN      55   46   )
MP_SCOLON      55   47   ;
MP_WRITELN     56   5   Writeln
MP_LPAREN      56   12   (
MP_STRING_LIT  56   13   
MP_RPAREN      56   13   )
MP_SCOLON      56   14   ;
MP_WRITELN     57   5   Writeln
MP_LPAREN      57   12   (
MP_STRING_LIT  57   13   
MP_RPAREN      57   13   )
MP_SCOLON      57   14   ;
MP_END         58   1   END
MP_PERIOD      58   4   .
MP_EOF         58   6   -1
