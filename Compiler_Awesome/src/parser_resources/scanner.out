MP_PROGRAM     1   1   program
MP_IDENTIFIER  1   9   Tester
MP_SCOLON      1   15   ;
MP_VAR         3   2   var
MP_IDENTIFIER  3   6   I
MP_COLON       3   7   :
MP_INTEGER     3   9   Integer
MP_SCOLON      3   16   ;
MP_PROCEDURE   5   5   procedure
MP_IDENTIFIER  5   15   junk
MP_LPAREN      5   20   (
MP_VAR         5   21   VAR
MP_IDENTIFIER  5   25   test
MP_COLON       5   29   :
MP_FLOAT       5   30   Float
MP_RPAREN      5   35   )
MP_SCOLON      5   36   ;
MP_BEGIN       6   5   begin
MP_READ        7   9   read
MP_LPAREN      7   13   (
MP_IDENTIFIER  7   14   somestuff
MP_RPAREN      7   23   )
MP_END         8   5   end
MP_SCOLON      8   8   ;
MP_COMMENT     8   10   {tester}
MP_FUNCTION    10   5   function
MP_IDENTIFIER  10   14   junk
MP_LPAREN      10   19   (
MP_VAR         10   20   VAR
MP_IDENTIFIER  10   24   test
MP_COLON       10   28   :
MP_FLOAT       10   29   Float
MP_RPAREN      10   34   )
MP_COLON       10   36   :
MP_BOOLEAN     10   38   Boolean
MP_SCOLON      10   45   ;
MP_BEGIN       11   5   begin
MP_READ        12   9   read
MP_LPAREN      12   13   (
MP_IDENTIFIER  12   14   somestuff
MP_RPAREN      12   23   )
MP_END         13   5   end
MP_SCOLON      13   8   ;
MP_COMMENT     13   10   {tester}
MP_FUNCTION    15   5   function
MP_IDENTIFIER  15   14   junk
MP_LPAREN      15   19   (
MP_VAR         15   20   VAR
MP_IDENTIFIER  15   24   test
MP_COLON       15   28   :
MP_FLOAT       15   29   Float
MP_RPAREN      15   34   )
MP_COLON       15   36   :
MP_STRING      15   38   STRING
MP_SCOLON      15   44   ;
MP_BEGIN       16   5   begin
MP_READ        17   9   read
MP_LPAREN      17   13   (
MP_IDENTIFIER  17   14   somestuff
MP_RPAREN      17   23   )
MP_END         18   5   end
MP_SCOLON      18   8   ;
MP_COMMENT     18   10   {tester}
MP_FUNCTION    20   5   function
MP_IDENTIFIER  20   14   junk
MP_LPAREN      20   19   (
MP_VAR         20   20   VAR
MP_IDENTIFIER  20   24   test
MP_COLON       20   28   :
MP_FLOAT       20   29   Float
MP_RPAREN      20   34   )
MP_COLON       20   36   :
MP_FLOAT       20   38   FLOAT
MP_SCOLON      20   43   ;
MP_BEGIN       21   5   begin
MP_READ        22   9   read
MP_LPAREN      22   13   (
MP_IDENTIFIER  22   14   somestuff
MP_RPAREN      22   23   )
MP_END         23   5   end
MP_SCOLON      23   8   ;
MP_COMMENT     23   10   {tester}
MP_COMMENT     25   1   {procedure this (VAR example:integer x)}
MP_BEGIN       26   3   begin
MP_COMMENT     26   9   {tester}
MP_WRITELN     27   5   Writeln
MP_LPAREN      27   12   (
MP_STRING_LIT  27   13   hi
MP_RPAREN      27   15   )
MP_SCOLON      27   16   ;
MP_WRITELN     27   18   Writeln
MP_LPAREN      27   25   (
MP_STRING_LIT  27   26   THis is a crazy string for testing purposes.
MP_RPAREN      27   70   )
MP_SCOLON      27   71   ;
MP_WRITE       28   5   Write
MP_LPAREN      28   10   (
MP_STRING_LIT  28   11   Please enter an integer value for I: 
MP_RPAREN      28   48   )
MP_SCOLON      28   49   ;
MP_READ        29   5   Read
MP_LPAREN      29   9   (
MP_IDENTIFIER  29   10   I
MP_RPAREN      29   11   )
MP_SCOLON      29   12   ;
MP_IDENTIFIER  30   5   I
MP_ASSIGN      30   7   :=
MP_IDENTIFIER  30   11   I
MP_PLUS        30   13   +
MP_INTEGER_LIT 30   15   1
MP_SCOLON      30   16   ;
MP_FOR         32   5   FOR
MP_IDENTIFIER  32   9   I
MP_ASSIGN      32   10   :=
MP_INTEGER_LIT 32   13   5
MP_TO          32   15   to
MP_INTEGER_LIT 32   18   12
MP_DO          32   21   do
MP_IF          33   9   If
MP_IDENTIFIER  33   12   I
MP_GEQUAL      33   14   >=
MP_INTEGER_LIT 33   18   6
MP_THEN        33   20   then
MP_WRITE       34   13   Write
MP_LPAREN      34   19   (
MP_STRING_LIT  34   21   this stuff
MP_RPAREN      34   31   )
MP_ELSE        35   9   else
MP_WRITE       36   13   Write
MP_LPAREN      36   19   (
MP_STRING_LIT  36   21   that stuff
MP_RPAREN      36   31   )
MP_SCOLON      36   32   ;
MP_IDENTIFIER  37   9   I
MP_ASSIGN      37   11   :=
MP_IDENTIFIER  37   15   I
MP_PLUS        37   17   +
MP_INTEGER_LIT 37   19   1
MP_SCOLON      37   20   ;
MP_FOR         39   5   FOR
MP_IDENTIFIER  39   9   I
MP_ASSIGN      39   10   :=
MP_INTEGER_LIT 39   13   5
MP_DOWNTO      39   15   downto
MP_INTEGER_LIT 39   22   12
MP_DO          39   25   do
MP_IF          40   9   If
MP_IDENTIFIER  40   12   I
MP_LEQUAL      40   14   <=
MP_INTEGER_LIT 40   18   6
MP_THEN        40   20   then
MP_WRITE       41   13   Write
MP_LPAREN      41   19   (
MP_STRING_LIT  41   21   this stuff
MP_RPAREN      41   31   )
MP_ELSE        42   9   else
MP_WRITE       43   13   Write
MP_LPAREN      43   19   (
MP_STRING_LIT  43   21   that stuff
MP_RPAREN      43   31   )
MP_SCOLON      43   32   ;
MP_IDENTIFIER  44   9   I
MP_ASSIGN      44   11   :=
MP_IDENTIFIER  44   15   I
MP_PLUS        44   17   +
MP_INTEGER_LIT 44   19   1
MP_SCOLON      44   20   ;
MP_WHILE       47   5   While
MP_LPAREN      47   11   (
MP_IDENTIFIER  47   12   I
MP_NEQUAL      47   14   <>
MP_INTEGER_LIT 47   18   20
MP_RPAREN      47   20   )
MP_DO          47   22   do
MP_IDENTIFIER  48   9   I
MP_ASSIGN      48   11   :=
MP_IDENTIFIER  48   15   I
MP_PLUS        48   17   +
MP_INTEGER_LIT 48   19   1
MP_SCOLON      48   20   ;
MP_REPEAT      50   5   Repeat
MP_IDENTIFIER  51   9   I
MP_ASSIGN      51   11   :=
MP_INTEGER_LIT 51   15   5
MP_UNTIL       52   9   until
MP_LPAREN      52   15   (
MP_IDENTIFIER  52   16   I
MP_NEQUAL      52   18   <>
MP_INTEGER_LIT 52   22   5
MP_RPAREN      52   23   )
MP_SCOLON      52   24   ;
MP_WRITELN     54   5   Writeln
MP_LPAREN      54   12   (
MP_STRING_LIT  54   13   The current value of I is 
MP_COMMA       54   39   ,
MP_IDENTIFIER  54   41   I
MP_EQUAL       54   43   =
MP_INTEGER_LIT 54   45   0
MP_RPAREN      54   46   )
MP_SCOLON      54   47   ;
MP_WRITELN     55   5   Writeln
MP_LPAREN      55   12   (
MP_STRING_LIT  55   13   
MP_RPAREN      55   13   )
MP_SCOLON      55   14   ;
MP_WRITELN     56   5   Writeln
MP_LPAREN      56   12   (
MP_STRING_LIT  56   13   
MP_RPAREN      56   13   )
MP_SCOLON      56   14   ;
MP_END         57   1   END
MP_PERIOD      57   4   .
MP_COMMENT     57   6   {tester}
MP_EOF         59   1   -1
